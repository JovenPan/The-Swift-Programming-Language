# 高级操作符

除了《基础操作符》里讲到的操作符，Swift还提供了一些高级操作符，用以完成更复杂的数值运算。比如位运算和移位操作符，其语法同C和Objective-C类似。

和C语言的算术操作符不同，Swift默认不支持溢出运算。数值溢出会被捕获并报错。但是，Swift提供了另一套支持溢出运算的操作符，比如可溢出加操作符（&+），可溢出操作符都以&作为前缀。

在自定义结构体、类或者枚举类型中，可以重载Swift操作符。通过操作符重载，可以简单地实现操作符的重定义。

Swift允许用户自定义操作符，并且可定制这些操作符的优先级和结合性。


## 位操作符

位操作符可以处理数据结构中的比特位，通常在图像处理和设备驱动等底层开发程序中使用。通过位操作符，还可以有效地处理外部数据源，比如使用自定义协议进行通信时用来编解码数据。

Swift支持C语言里所有的位操作符，如下所述：

### 按位非

按位非操作符（~）对操作数每一位取反：

按位非是前置操作符，紧置于操作数之前，不带空格：

```
let initialBits: UInt8 = 0b00001111
let invertedBits = ~initialBits // 等于 11110000
```

UInt8 是8位无符号整型，可以存储0-255之间的任意数。这个例子先初始化了一个UInt8 整型变量initialBits，二进制值为00001111，前四位为0，后四位为1，换算成十进制等于15。


接着将这个变量initialBits进行按位非操作得到常量invertedBits，0变成1，1变成0，得到的二进制值为11110000，换算成十进制等于240。

### 按位与

按位与操作符（&）有两个操作数。按位与操作就是将两个操作数的每一位对齐，当对应位都是1时返回1，其他情况都返回0。

以下代码，firstSixBits 和lastSixBits 中间4个位都等于1，将它们按位与操作后得到二进制数00111100，换算成十进制为60：

```
let firstSixBits: UInt8 = 0b11111100
let lastSixBits: UInt8 = 0b00111111
let middleFourBits = firstSixBits & lastSixBits // 等于 00111100
```

### 按位或

按位或操作符（|）也有两个操作数。按位或操作就是将两个操作数的每一位对齐，当对应位有一个是1时就返回1，而只有两个位都是0的情况才返回0。

以下代码，someBits 和moreBits 在不同位上有1，将它们按位或操作后得到二进制数11111110，换算成十进制为254：

```
let someBits: UInt8 = 0b10110010
let moreBits: UInt8 = 0b01011110
let combinedbits = someBits | moreBits // 等于 11111110
```

### 按位异或

按位异或操作符（^）比较两个操作数的对应位，当两个位不同时返回1，相同时返回0。

以下代码，firstBits 和otherBits 对应位相同的情况返回0，不同的情况返回1：

```
let firstBits: UInt8 = 0b00010100
let otherBits: UInt8 = 0b00000101
let outputBits = firstBits ^ otherBits // 等于 00010001
```

## 按位左移、右移操作符

左移操作符（<<）和右移操作符（）将操作数的所有位向左或向右移动指定的位数。

按位左移和右移的效果等同于将操作数乘以或除以2的倍数。向左移动一位相当于将操作数乘以2，向右移动一位相当于将操作数除以2。


### 无符号移位操作

无符号移位的规则如下：

1.	已有的位向左或向右移动指定的位数。
2.	舍弃超出边界的位。.
3.	移动后产生的空位用0填充。

这种方法称为逻辑移位。

下图展示了11111111 << 1（11111111 左移一位）和11111111 >> 1（11111111 右移一位）的结果。蓝色数字表示被移动位，灰色表示被丢弃位，空位用橙色的0填充。

Swift移位操作代码：

```
let shiftBits: UInt8 = 4 // 即二进制的00000100
shiftBits << 1 // 00001000
shiftBits << 2 // 00010000
shiftBits << 5 // 10000000
shiftBits << 6 // 00000000
shiftBits >> 2 // 00000001
```

移位操作可以对其他数据类型实现编码和解码：

```
let pink: UInt32 = 0xCC6699
let redComponent = (pink & 0xFF0000) >> 16 // redComponent是0xCC, 即204
let greenComponent = (pink & 0x00FF00) >> 8 // greenComponent是0x66, 即102
let blueComponent = pink & 0x0000FF // blueComponent是0x99, 即153
```

这个例子中用一个UInt32 常量pink 来存储css中粉色的颜色值。CSS中颜色#CC6699在Swift用十六进制0xCC6699来表示。这个颜色值经过按位与（&）和按位右移操作后可分解出它的红色成分（CC）、绿色成分（66）和蓝色成分（99）。

对0xCC6699 和0xFF0000进行按位与操作就可以得到红色成分。0xFF0000 里的0类似于遮罩，将0xCC6699的第二和第三字节过滤掉后返回0xCC0000 。

然后，将0xCC0000 向右移动16位。因为十六进制中每两个字符占8个比特位，所以移动16位的结果是把0xCC0000 变成0x0000CC，等同于0xCC，换算成十进制是204。

同理，对0xCC6699 和0x00FF00进行按位与操作可以得到绿色成分。将结果值0x006600再向右移动8位得到0x66，换算成十进制是102。

最后，对0xCC6699 和0x0000FF进行按位与操作可以得到蓝色成分。结果值0x000099不需要再做移位操作，因为0x000099 等价于0x99，换算成十进制是153。





